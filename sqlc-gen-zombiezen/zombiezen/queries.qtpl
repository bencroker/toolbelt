{% import "github.com/delaneyj/toolbelt" %}

{% func GenerateQuery(q *GenerateQueryContext) %}
// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package {%s q.PackageName.Lower %}

import (
    "fmt"
    "zombiezen.com/go/sqlite"

    {% if q.NeedsTimePackage %}
    "time"
    "github.com/delaneyj/toolbelt"
    {% endif %}
)


{% if q.HasResponse && !q.ResponseIsSingularField %}
type {%s q.Name.Pascal %}Res struct {
    {%- for _,f := range q.ResponseFields -%}
        {%s f.Name.Pascal %} {%s f.GoType.Original %} `json:"{%s f.Name.Lower %}"`
    {%- endfor -%}
}
{% endif %}

{% if q.HasParams && !q.ParamsIsSingularField %}
type {%s q.Name.Pascal %}Params struct {
    {%- for _,f := range q.Params -%}
        {%s f.Name.Pascal %} {%s f.GoType.Original %} `json:"{%s f.Name.Lower %}"`
    {%- endfor -%}
}
{% endif %}

type {%s q.Name.Pascal %}Stmt struct {
    stmt *sqlite.Stmt
}

func {%s q.Name.Pascal %}(tx *sqlite.Conn) *{%s q.Name.Pascal %}Stmt {
    // Prepare the statement into connection cache
    stmt := tx.Prep(`
{%s= q.SQL %}
    `)
    ps := &{%s q.Name.Pascal %}Stmt{stmt: stmt}
    return ps
}

func (ps *{%s q.Name.Pascal %}Stmt) Run(
    {%= fillReqParams(q) -%}
) (
    {%= fillReturns(q) -%}
) {
    defer ps.stmt.Reset()

{%- if len(q.Params) > 0 %}
    // Bind parameters
    {%- for _,p := range q.Params -%}
        {%= fillParams(p.GoType, p.SQLType, p.Name, p.Column, q.ParamsIsSingularField) %}
    {%- endfor -%}
{%- endif -%}

    // Execute the query
{%- if q.HasResponse -%}
    {%- if q.ResponseHasMultiple -%}
        for {
            if hasRow, err := ps.stmt.Step(); err != nil {
                return res, fmt.Errorf("failed to execute {{.Name.Lower}} SQL: %w", err)
            } else if !hasRow {
                break
            }
            {%= fillResponse(q) -%}

            res = append(res, row)
        }
    {%- else -%}
        if hasRow, err := ps.stmt.Step(); err != nil {
            {%- if q.ResponseIsSingularField -%}
            return {%s q.ResponseFields[0].Name.Camel %}, fmt.Errorf("failed to execute {{.Name.Lower}} SQL: %w", err)
            {%- else -%}
            return res, err
            {%- endif -%}
        } else if hasRow {
            {%= fillResponse(q) -%}
            {%- if !q.ResponseIsSingularField -%}
            res = &row
            {%- endif -%}
        }
    {%- endif -%}
{%- else -%}
    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to execute {%s q.Name.Lower %} SQL: %w", err)
    }
{%- endif -%}

{%- if q.HasResponse -%}
    {%- if q.ResponseIsSingularField -%}
    return {%s q.ResponseFields[0].Name.Camel %}, nil
    {%- else -%}
    return res, nil
    {%- endif -%}
{%- else -%}
    return nil
{%- endif -%}
}

func Once{%s q.Name.Pascal %}(
    tx *sqlite.Conn,
    {%= fillReqParams(q) -%}
) (
    {%= fillReturns(q) -%}
) {
    ps := {%s q.Name.Pascal %}(tx)

    return ps.Run(
    {%- if q.HasParams -%}
        {% if q.ParamsIsSingularField -%}
            {%s q.Params[0].Name.Camel -%} ,
        {%- else -%}
            params,
        {%- endif -%}
    {%- endif %}
    )
}

{% endfunc %}

{%- func fillResponse(q *GenerateQueryContext) %}
{%- if q.ResponseIsSingularField -%}
    {%- code
        f := q.ResponseFields[0]
     -%}
    {%- switch f.GoType.Original -%}
        {%- case "time.Time" -%}
            {%s f.Name.Camel %} = toolbelt.JulianDayToTime(ps.stmt.ColumnFloat({%d f.Offset %}))
        {%- case "time.Duration" -%}
            {%s f.Name.Camel %} = toolbelt.MillisecondsToDuration(ps.stmt.ColumnInt64({%d f.Offset %}))
        {%- case "[]byte" -%}
            {%s f.Name.Camel %} = toolbelt.StmtBytesByCol(ps.stmt, {%d f.Offset %}),
        {%- default -%}
            {%s f.Name.Camel %} = ps.stmt.Column{%s f.SQLType.Pascal %}({%d f.Offset %})
    {%- endswitch -%}
{%- else -%}
    row := {%s q.Name.Pascal %}Res{
    {%- for _,f := range q.ResponseFields -%}
        {%- switch f.GoType.Original -%}
            {%- case "time.Time" -%}
                {%s f.Name.Pascal %}: toolbelt.JulianDayToTime(ps.stmt.ColumnFloat({%d f.Offset %})),
            {%- case "time.Duration" -%}
                {%s f.Name.Pascal %}: toolbelt.MillisecondsToDuration(ps.stmt.ColumnInt64({%d f.Offset %})),
            {%- case "[]byte" -%}
                {%s f.Name.Pascal %}: toolbelt.StmtBytesByCol(ps.stmt, {%d f.Offset %}),
            {%- default -%}
                {%s f.Name.Pascal %}: ps.stmt.Column{%s f.SQLType.Pascal %}({%d f.Offset %}),
        {%- endswitch -%}
    {%- endfor -%}
    }
{%- endif %}
{%- endfunc %}

{%- func fillReqParams(q *GenerateQueryContext) -%}
{%- if q.HasParams -%}
    {%- if q.ParamsIsSingularField -%}
        {%s q.Params[0].Name.Camel %} {%s q.Params[0].GoType.Original -%},
    {%- else -%}
        params {%s q.Name.Pascal %}Params,
    {%- endif -%}
{%- endif -%}
{%- endfunc  -%}


{%- func fillReturns(q *GenerateQueryContext) -%}
{%- if q.HasResponse -%}
    {%- if q.ResponseIsSingularField -%}
        {%s q.ResponseFields[0].Name.Camel %} {%s q.ResponseFields[0].GoType.Original -%},
    {%- else -%}
        res {% if q.ResponseHasMultiple %}[]{% else %}*{% endif %}{%s q.Name.Pascal %}Res,
    {%- endif -%}
{%- endif -%}
    err error,
{%- endfunc -%}

{%- func fillParams(goType, sqlType, name toolbelt.CasedString, col int, isSingle bool) -%}
{%- switch goType.Original -%}
    {%- case "time.Time" -%}
        ps.stmt.Bind{%s sqlType.Pascal %}({%d col %}, toolbelt.TimeToJulianDay({%if isSingle %}{%s name.Camel %}{%else %}params.{%s name.Pascal %}{% endif %}))
    {%- case "time.Duration" -%}
        ps.stmt.Bind{%s sqlType.Pascal %}({%d col %}, toolbelt.DurationToMilliseconds({%if isSingle %}{%s name.Camel %}{%else %}params.{%s name.Pascal %}{% endif %}))
    {%- default -%}
        ps.stmt.Bind{%s sqlType.Pascal %}({%d col %}, {%if isSingle %}{%s name.Camel %}{%else %}params.{%s name.Pascal %}{% endif %})
{%- endswitch -%}
{%- endfunc -%}
`
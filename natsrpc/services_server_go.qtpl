{% func goServerTemplate(pkg *packageTmplData) %}
// Code generated by protoc-gen-go-nrpc. DO NOT EDIT.

package {%s pkg.PackageName.Snake %}

import (
    "context"
    "errors"
    "fmt"
    "log"

    "github.com/nats-io/nats.go"
    "google.golang.org/protobuf/proto"
    "gopkg.in/typ.v4/sync2"
)

{%- for _, service := range pkg.Services -%}
    {%- code
        nsp := service.Name.Pascal
    -%}

type {%s nsp %}Service interface {
    OnClose() error

    //#region Methods
    {%- for _, method := range service.Methods -%}
        {%- code
        cs := method.IsClientStreaming
        ss := method.IsServerStreaming
        -%}
        {%- switch  -%}
        {%- case !cs && !ss  -%}
            {%s method.Name.Pascal %}(ctx context.Context, req *{%s method.InputType.Original %}) (res *{%s method.OutputType.Original %}, err error)
        {%- case cs && !ss -%}
            {%s method.Name.Pascal %}(ctx context.Context, reqCh <-chan *{%s method.InputType.Original %}) (res *{%s method.OutputType.Original %}, err error)
        {%- case !cs && ss -%}
            {%s method.Name.Pascal %}(ctx context.Context, req *{%s method.InputType.Original %}, resCh <-chan *{%s method.OutputType.Original %}, errCh <-chan error)
        {%- case cs && ss -%}
            {%s method.Name.Pascal %}(ctx context.Context, reqCh <-chan *{%s method.InputType.Original %}, resCh chan<- *{%s method.OutputType.Original %}, errCh chan<- error) error
        {%- endswitch -%}
    {%- endfor -%}
    //#endregion
}

const (
    {%s nsp %}ServiceSubject = "{%s service.Subject %}"
    {%- for _, method := range service.Methods -%}
       {%s nsp %}Service{%s method.Name.Pascal %}Subject = "{%s method.Subject %}"
    {%- endfor -%}
)

type {%s nsp %}ServiceRunner struct {
    baseSubject string
    service {%s nsp %}Service
    nc *nats.Conn
}

func New{%s nsp %}ServiceRunner(nc *nats.Conn, service {%s nsp %}Service) (*{%s nsp %}ServiceRunner, error) {
    runner := &{%s nsp %}ServiceRunner{
        service: service,
        nc: nc,
    }

    {%- for _, method := range service.Methods -%}
        {%- code
            subjectName := nsp + "Service" + method.Name.Pascal + "Subject"
            ss,cs := method.IsServerStreaming, method.IsClientStreaming

        -%}
        {%- switch  -%}
        {%- case !cs && !ss  -%}
            {%= goServerUnaryHandler(subjectName, method) %}
        {%- case cs && !ss -%}
            {%= goServerClientStreamHandler(subjectName, method) %}
        {%- case !cs && ss -%}
            {%= goServerServerStreamHandler(subjectName, method) %}
        {%- case cs && ss -%}
            {%= goServerBidiStreamHandler(subjectName, method) %}
        {%- endswitch -%}
    {%- endfor -%}

    return runner,nil
}

func (runner *{%s nsp %}ServiceRunner) Close() error {
    var errs []error
    if runner.service != nil {
        if err := runner.service.OnClose(); err != nil {
            errs = append(errs, err)
        }
    }

    if err := errors.Join(errs...); err != nil {
        return fmt.Errorf("failed to close runner: %w", err)
    }

    return nil
}

{%- endfor -%}

{% endfunc %}


{% func goServerUnaryHandler(subjectName string, method *methodTmplData) %}
// Unary call for {%s method.Name.Pascal %}
nc.Subscribe({%s subjectName %}, func(msg *nats.Msg) {
        req := &{%s method.InputType.Original %}{}
		if err := proto.Unmarshal(msg.Data, req); err != nil {
			sendError(msg, fmt.Errorf("failed to unmarshal request: %w", err))
			return
		}

		res, err := runner.service.{%s method.Name.Pascal %}(context.Background(),req)
		if err != nil {
			sendError(msg, err)
			return
		}
		sendSuccess(msg, res)
	})
{% endfunc %}

{% func goServerClientStreamHandler(subjectName string, method *methodTmplData) %}
{% code
reqChName := method.Name.Camel + "ClientReqChs"
inputName := method.InputType.Original
%}
// Client streaming call for {%s method.Name.Pascal %}
{%s reqChName %} := sync2.Map[string, chan *{%s= inputName  %}]{}
nc.Subscribe({%s subjectName %}, func(msg *nats.Msg) {
		// Check for end of stream
		if len(msg.Data) == 0 {
			log.Printf("Got EOF")
			reqCh, ok := {%s reqChName %}.Load(msg.Reply)
			if !ok {
				sendError(msg, errors.New("no request channel found"))
				return
			}
			close(reqCh)
			{%s reqChName %}.Delete(msg.Reply)
			return
		}

		// Check for request
		req := &{%s= inputName  %}{}
		if err := proto.Unmarshal(msg.Data, req); err != nil {
			sendError(msg, fmt.Errorf("failed to unmarshal request: %w", err))
			return
		}

		log.Printf("Got request: %v", req)

		// Check for request channel
		reqCh, ok := {%s reqChName %}.Load(msg.Reply)
		if !ok {
			reqCh = make(chan *{%s= inputName  %})

			{%s reqChName %}.Store(msg.Reply, reqCh)

			go func() {
				res, err := runner.service.{%s method.Name.Pascal %}(context.Background(),reqCh)
				if err != nil {
					sendError(msg, err)
					return
				}
				sendSuccess(msg, res)
			}()
		}
		reqCh <- req
	})
{% endfunc %}

{% func goServerServerStreamHandler(subjectName string, method *methodTmplData) %}
// Server streaming call for {%s method.Name.Pascal %}
nc.Subscribe({%s subjectName %}, func(msg *nats.Msg) {
    req := &{%s method.InputType.Original %}{}
    if err := proto.Unmarshal(msg.Data, req); err != nil {
        sendError(msg, fmt.Errorf("failed to unmarshal request: %w", err))
        return
    }

	resCh := make(chan *{%s method.OutputType.Original %})
	errCh := make(chan error)

	// User defined handler
	go runner.service.{%s method.Name.Pascal%}(context.Background(), req, resCh, errCh)

	// Send responses to client
	go func () {
		defer sendEOF(msg)
		for {
			select {
			case res, ok := <-resCh:
				if !ok {
					return
				}
				sendSuccess(msg, res)
			case err := <-errCh:
				if err == nil {
					return
				}
				sendError(msg, err)
				return
			}
		}
	}()
})
{% endfunc %}

{% func goServerBidiStreamHandler(subjectName string, method *methodTmplData) %}
{% code
reqChName := method.Name.Camel + "BiReqChs"
inputName := method.InputType.Original
%}
// Bidirectional streaming call for {%s method.Name.Pascal %}
{%s reqChName %} := sync2.Map[string, chan *{%s= inputName  %}]{}
nc.Subscribe({%s subjectName %}, func(msg *nats.Msg) {
		// Check for end of stream
		if len(msg.Data) == 0 {
			reqCh, ok := {%s reqChName %}.Load(msg.Reply)
			if !ok {
				sendError(msg, errors.New("no request channel found"))
				return
			}
			close(reqCh)
			{%s reqChName %}.Delete(msg.Reply)
			return
		}

		// Check for request
		req := &{%s= inputName  %}{}
		if err := proto.Unmarshal(msg.Data, req); err != nil {
			sendError(msg, fmt.Errorf("failed to unmarshal request: %w", err))
			return
		}

		// Check for request channel
		reqCh, ok := {%s reqChName %}.Load(msg.Reply)
		if !ok {
			reqCh = make(chan *{%s= inputName  %})
			{%s reqChName %}.Store(msg.Reply, reqCh)

			go func() {
				defer sendEOF(msg)

				resCh := make(chan *{%s method.OutputType.Original %})
				errCh := make(chan error)

				go func() {
					for {
						select {
						case res, ok := <-resCh:
							if !ok {
								return
							}
							sendSuccess(msg, res)
						case err := <-errCh:
							sendError(msg, err)
							return
						}
					}
				}()
				if err := runner.service.{%s method.Name.Pascal %}(context.Background(), reqCh, resCh, errCh); err != nil {
					sendError(msg, err)
					return
				}
			}()
		}
		reqCh <- req
	})
{% endfunc %}

{% func goClientTemplate(pkg *packageTmplData) %}
// Code generated by protoc-gen-go-nrpc. DO NOT EDIT.

package {%s pkg.PackageName.Snake %}

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/nats-io/nats.go"
	"google.golang.org/protobuf/proto"
)

{% for _,svc := range pkg.Services %}
    {% code clientName := svc.Name.Pascal + "NATSClient" %}

    type {%s clientName %} struct {
        nc *nats.Conn
    }

    func New{%s clientName %}(nc *nats.Conn) (*{%s clientName %}, error) {
        client := &{%s clientName %}{
            nc: nc,
        }
        return client, nil
    }

    func(client *{%s clientName %}) Close() error {
        return client.nc.Drain()
    }

    {% for _,method := range svc.Methods %}
        {% code cs,ss  := method.IsClientStreaming, method.IsServerStreaming %}
        {% switch  %}
            {% case !cs && !ss -%}
                {%= goClientUnaryHandler(method) -%}
            {% case cs && !ss -%}
                {%= goClientClientStreamHandler(method) -%}
            {% case !cs && ss -%}
                {%= goClientServerStreamHandler(method) -%}
            {% case cs && ss -%}
                {%= goClientBidiStreamHandler(method) -%}
        {% endswitch %}
    {% endfor %}

{% endfor %}
{% endfunc %}

{% func goClientUnaryHandler(method *methodTmplData) %}
{% code
    sn := method.Subject
	mn  := method.Name.Pascal
	in := method.InputType.Original
	out := method.OutputType.Original
%}
// Unary call for {%s mn %}
func (c *{%s method.ServiceName.Pascal %}NATSClient) {%s mn %}(ctx context.Context, req *{%s in %}, opts ...NatsRpcOption) (*{%s out %}, error){
	reqBytes, err := proto.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	opt := NewNatsRpcOptions(opts...)

	msg, err := c.nc.Request("{%s sn %}", reqBytes, opt.Timeout)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}

	res := &{%s out %}{}
	if err := proto.Unmarshal(msg.Data, res); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return res, nil
}
{% endfunc %}

{% func goClientClientStreamHandler(method *methodTmplData) %}
{% code
	sn := method.Subject
	mn  := method.Name.Pascal
	in := method.InputType.Original
	out := method.OutputType.Original
%}
// Client streaming call for {%s mn %}
func( c *{%s method.ServiceName.Pascal %}NATSClient) {%s mn %}(ctx context.Context, reqGen func(reqCh chan<- *{%s in %}) error, opts ...NatsRpcOption) (res *{%s out %}, err error) {
	mailbox := nats.NewInbox()

	var (
		sub   *nats.Subscription
		resCh = make(chan *{%s out %})
		opt   = NewNatsRpcOptions(opts...)
	)
	sub, err = c.nc.Subscribe(mailbox, func(msg *nats.Msg) {
		log.Print("Got response from server")
		defer sub.Unsubscribe()
		defer close(resCh)

		t := time.NewTimer(opt.Timeout)

		select {
		case <-ctx.Done():
			err = ctx.Err()
			return
		case <-t.C:
			err = fmt.Errorf("timeout")
			return
		default:
			res = &{%s out %}{}
			if err = proto.Unmarshal(msg.Data, res); err != nil {
				res = nil
				err = fmt.Errorf("failed to unmarshal response: %w", err)
				return
			}
			resCh <- res
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to response: %w", err)
	}

	doneReqGen := make(chan struct{})
	reqCh := make(chan *{%s in %})
	go func() {
		defer func(){
			eofMsg := &nats.Msg{
				Subject: "{%s sn %}",
				Reply:   mailbox,
				Data: nil,
			}
			c.nc.PublishMsg(eofMsg)
		}()

		if err = reqGen(reqCh); err != nil {
			err = fmt.Errorf("failed to generate requests: %w", err)
			return
		}

		<-doneReqGen
	}()

	for req := range reqCh {
		log.Printf("Sending request to server: %v", req)
		reqBytes, err := proto.Marshal(req)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal request: %w", err)
		}
		msg := &nats.Msg{
			Subject: "{%s sn %}",
			Reply:   mailbox,
			Data:    reqBytes,
		}
		if err = c.nc.PublishMsg(msg); err != nil {
			return nil, fmt.Errorf("failed to send request: %w", err)
		}
	}
	doneReqGen <- struct{}{}

	res = <-resCh
	return
}
{% endfunc %}

{% func goClientServerStreamHandler(method *methodTmplData) %}
{% code
	sn := method.Subject
	mn  := method.Name.Pascal
	in := method.InputType.Original
	out := method.OutputType.Original
%}
// Server streaming call for {%s mn %}
func( c *{%s method.ServiceName.Pascal %}NATSClient) {%s mn %}(ctx context.Context, req *{%s in %}, onRes func(res *{%s out %}) error, opt ...NatsRpcOption) ( error) {
	reqBytes, err := proto.Marshal(req)
	if err != nil {
		return fmt.Errorf("failed to marshal request: %w", err)
	}

	mailbox := nats.NewInbox()
	msg := &nats.Msg{
		Subject: "{%s sn %}",
		Reply :mailbox,
		Data:  reqBytes,
	}

	errCh := make(chan error)

	sub, err := c.nc.Subscribe(mailbox, func(msg *nats.Msg) {
		if len(msg.Data) == 0 {
			errCh <- nil
		}

		res :=  &{%s out %}{}
		if err := proto.Unmarshal(msg.Data, res); err != nil {
			errCh <- fmt.Errorf("failed to unmarshal response: %w", err)
		}

		if err := onRes(res); err != nil {
			errCh <- fmt.Errorf("failed to handle response: %w", err)
		}
	})
	if err != nil {
		return fmt.Errorf("failed to subscribe: %w", err)
	}
	defer sub.Unsubscribe()

	if err := c.nc.PublishMsg(msg); err != nil {
		return fmt.Errorf("failed to send request: %w", err)
	}

	if err := <-errCh; err != nil {
		return fmt.Errorf("failed to handle response: %w", err)
	}

	return nil
}
{% endfunc %}

{% func goClientBidiStreamHandler( method *methodTmplData) %}
{% code
    sn := method.Subject
    mn  := method.Name.Pascal
    in := method.InputType.Original
    out := method.OutputType.Original
%}
type Bidirectional{%s mn %}Func func(ctx context.Context, reqCh chan<- *{%s in %}, resCh <-chan *{%s out %}) error
// Bidi streaming call for {%s mn %}
func(c *{%s method.ServiceName.Pascal %}NATSClient) {%s mn %}(biDirectionalFunc Bidirectional{%s mn %}Func) error {
	var (
		mailbox      = nats.NewInbox()
		serverResSub *nats.Subscription
		errCh        = make(chan error)
		reqCh        = make(chan *{%s in  %})
		resCh        = make(chan *{%s out %})
		doneCh       = make(chan struct{})
	)
	defer close(resCh)
	defer close(doneCh)
	defer close(errCh)

	// Handle server responses
	serverResSub, err := c.nc.Subscribe(mailbox, func(msg *nats.Msg) {
		log.Print("Got response from server")

		if len(msg.Data) == 0 {
			doneCh <- struct{}{}
			return
		}

		res := &{%s out %}{}
		if err := proto.Unmarshal(msg.Data, res); err != nil {
			errCh <- fmt.Errorf("failed to unmarshal response: %w", err)
			return
		}
		resCh <- res
	})
	if err != nil {
		return fmt.Errorf("failed to subscribe to response: %w", err)
	}
	defer serverResSub.Unsubscribe()

	ctx := context.Background()

	// Start user defined bidirectional handler
	go func() {
		if err := biDirectionalFunc(ctx, reqCh, resCh); err != nil {
			errCh <- fmt.Errorf("failed to handle bidi stream: %w", err)
		}
	}()

	// Take requests from user defined handler and send them to server
	go func() {
		for req := range reqCh {
			log.Printf("Sending request to server: %v", req)
			reqBytes, err := proto.Marshal(req)
			if err != nil {
				errCh <- fmt.Errorf("failed to marshal request: %w", err)
				return
			}
			msg := &nats.Msg{
				Subject: "{%s sn %}",
				Reply:   mailbox,
				Data:    reqBytes,
			}
			if err = c.nc.PublishMsg(msg); err != nil {
				errCh <- fmt.Errorf("failed to send request: %w", err)
				return
			}
		}
		doneCh <- struct{}{}
	}()

	// Wait for context cancellation, error from user defined handler or EOF from server
	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case err := <-errCh:
			if err != nil {
				return fmt.Errorf("failed to handle bidi stream: %w", err)
			}
			return nil
		case <-doneCh:
			return nil
		}
	}
}

{% endfunc %}


{% func goKVTemplate(pkg *packageTmplData) %}
// Code generated by protoc-gen-go-natsrpc. DO NOT EDIT.

package {%s pkg.PackageName.Snake %}

import (
    "context"
	"fmt"
	"time"
    "errors"
    "github.com/nats-io/nats.go/jetstream"
    "google.golang.org/protobuf/proto"
)

{% for _, kv := range pkg.KeyValues %}
type {%s kv.Name.Pascal %}KV struct {
    kv jetstream.KeyValue
}

func(tkv *{%s kv.Name.Pascal %}KV) new{%s kv.Name.Pascal %}()  *{%s kv.Name.Pascal %}{
    return &{%s kv.Name.Pascal %}{}
}

func(tkv *{%s kv.Name.Pascal %}KV) id(msg *{%s kv.Name.Pascal %}) string {
    {%- if kv.IdIsString -%}
    return msg.{%s kv.ID.Pascal%}
    {%- else -%}
    return fmt.Sprint(msg.{%s kv.ID.Pascal %})
    {%- endif -%}
}

// should generate kv bucket for {%s= kv.Bucket %} {%s kv.Name.Pascal %}
func Upsert{%s kv.Name.Pascal %}KV(ctx context.Context, js jetstream.JetStream) (*{%s kv.Name.Pascal %}KV, error) {
    ttl, err := time.ParseDuration("{%s kv.TTL.String() %}")
	if err != nil {
		return nil, fmt.Errorf("failed to parse duration: %w", err)
	}

	kvCfg := jetstream.KeyValueConfig{
		Bucket: "{%s= kv.Bucket %}",
		TTL: ttl,
		History: 1,
	}
	kv, err := js.CreateOrUpdateKeyValue(ctx, kvCfg)
	if err != nil {
		return nil, fmt.Errorf("failed to upsert kv: %w", err)
	}

    container := &{%s kv.Name.Pascal %}KV{
        kv: kv,
    }

	return container, nil
}

func (tkv *{%s kv.Name.Pascal %}KV) Keys(ctx context.Context, watchOpts ...jetstream.WatchOpt) ([]string, error) {
	keys, err := tkv.kv.Keys(ctx, watchOpts...)
	if err != nil && err != jetstream.ErrNoKeysFound {
		return nil, err
	}
	return keys, nil
}

func (tkv *{%s kv.Name.Pascal %}KV) Get(ctx context.Context, key string) (*{%s kv.Name.Pascal %}, uint64, error) {
	entry, err := tkv.kv.Get(ctx,key)
	if err != nil {
		if err == jetstream.ErrKeyNotFound {
			return nil, 0, nil
		}
	}
	out, err := tkv.unmarshal(entry)
	if err != nil {
		return out, 0, err
	}
	return out, entry.Revision(), nil
}

func (tkv *{%s kv.Name.Pascal %}KV) unmarshal(entry jetstream.KeyValueEntry) (*{%s kv.Name.Pascal %}, error) {
	if entry == nil {
		return nil, nil
	}
	b := entry.Value()
	if b == nil {
		return nil, nil
	}
	t := tkv.new{%s kv.Name.Pascal %}()
	if err := proto.Unmarshal(b, t); err != nil {
		return t, err
	}
	return t, nil
}

func (tkv *{%s kv.Name.Pascal %}KV) Load(ctx context.Context, keys ...string) ([]*{%s kv.Name.Pascal %}, error) {
	var errs []error
    loaded := make([]*{%s kv.Name.Pascal %}, len(keys))
    for i, key := range keys {
        t, _, err := tkv.Get(ctx, key)
        if err != nil {
            errs = append(errs, err)
        }
        loaded[i] = t
    }
	if len(errs) > 0 {
		return nil, errors.Join(errs...)
	}
	return loaded, nil
}

func (tkv *{%s kv.Name.Pascal %}KV) All(ctx context.Context) (out []*{%s kv.Name.Pascal %}, err error) {
	keys, err := tkv.kv.Keys(ctx)
	if err != nil {
		if err == jetstream.ErrNoKeysFound {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get all keys: %w", err)
	}
	return tkv.Load(ctx, keys...)
}

func (tkv *{%s kv.Name.Pascal %}KV) Set(ctx context.Context, value *{%s kv.Name.Pascal%}) (revision uint64, err error) {
	b, err := proto.Marshal(value)
	if err != nil {
		return 0, err
	}
	revision, err = tkv.kv.Put(ctx, tkv.id(value), b)
	return
}

func (tkv *{%s kv.Name.Pascal %}KV) Batch(ctx context.Context, values ... *{%s kv.Name.Pascal %}) (err error) {
    errs := make([]error, len(values))
    for i, value := range values {
        _, errs[i] = tkv.Set(ctx, value)
    }
    if err := errors.Join(errs...); err != nil {
        return fmt.Errorf("failed to batch set: %w", err)
    }
	return nil
}

func (tkv *{%s kv.Name.Pascal %}KV) Update(ctx context.Context, value *{%s kv.Name.Pascal %}, last uint64) (revision uint64, err error) {
	b, err := proto.Marshal(value)
	if err != nil {
		return 0, err
	}
	key := tkv.id(value)
	revision, err = tkv.kv.Update(ctx, key, b, last)
	return
}

func (tkv *{%s kv.Name.Pascal %}KV) DeleteKey(ctx context.Context, key string) (err error) {
	return tkv.kv.Delete(ctx, key)
}

func (tkv *{%s kv.Name.Pascal %}KV) Delete(ctx context.Context, value *{%s kv.Name.Pascal %}) (err error) {
	return tkv.kv.Delete(ctx, tkv.id(value))
}

type {%s kv.Name.Pascal %}Entry struct {
	Key string
	Op jetstream.KeyValueOp
	{%s kv.Name.Pascal %} *{%s kv.Name.Pascal %}
}

func (tkv *{%s kv.Name.Pascal %}KV) watch(ctx context.Context, w jetstream.KeyWatcher) (values <-chan *{%s kv.Name.Pascal %}Entry, stop func() error, err error) {
	ch := make(chan *{%s kv.Name.Pascal %}Entry)
	updates := w.Updates()
	go func(ctx context.Context, w jetstream.KeyWatcher) error {
		for {
			select {
			case <-ctx.Done():
				return nil
			case entry := <-updates:
				if entry == nil {
					continue
				}

				typeEntry := &{%s kv.Name.Pascal %}Entry{
					Key: entry.Key(),
					Op: entry.Operation(),
					{%s kv.Name.Pascal %}: nil,
				}

				if typeEntry.Op != jetstream.KeyValueDelete {
					t, err := tkv.unmarshal(entry)
					if err != nil {
						return err
					}
					typeEntry.{%s kv.Name.Pascal %} = t
				}

				ch <- typeEntry
			}
		}
	}(ctx, w)
	return ch, w.Stop, nil
}

func (tkv *{%s kv.Name.Pascal %}KV) Watch(ctx context.Context, key string, opts ...jetstream.WatchOpt) (values <-chan *{%s kv.Name.Pascal %}Entry, stop func() error, err error) {
	w, err := tkv.kv.Watch(ctx,key, opts...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to watch key %s: %w", key, err)
	}
	return tkv.watch(ctx, w)
}

func (tkv *{%s kv.Name.Pascal %}KV) WatchAll(ctx context.Context, opts ...jetstream.WatchOpt) (values <-chan *{%s kv.Name.Pascal %}Entry, stop func() error, err error) {
	w, err := tkv.kv.WatchAll(ctx,opts...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to watch all: %w", err)
	}
	return tkv.watch(ctx, w)
}

{% endfor %}
{% endfunc %}